
#' Create echogram curtain plot from interval-layer data.
#'
#' @param the.dir
#' Character, the directory containing the data that will be used to make the
#' plots.
#' @param d.units
#' Character, either "nph" or "gph".
#' @param spgrp
#' Character vector listing the species groups that should be plotted.
#' Must be entered in the form "X106.L100", for example, for alewife
#' (species code = 106) that are >= 100 mm long. These names are
#' in the form generated by the estimateLake() function.
#' @return
#' This function generates curtain plots for each species group
#' listed and every acoustic transect. The transects are facets,
#' the vertical axis is depth, and the horizontal axis is transect
#' interval number.
#'
#' @details
#' This function is intended to build on the plots in exploreACMT(). The plots
#' provide a view of the data that is not possible when looking at just Sv
#' or TS/sigma, as these two can interact in such a way as to generate fish
#' density that might be higher than expected given the appearance of the Sv
#' data.One key use for this sort of plot is to look for analysis cells that
#' have density that is higher than expected because of low numbers of targets.
#' @export
#'
#' @examples
#'
#' @importFrom magrittr "%>%"
#' @importFrom lubridate today
#' @importFrom scales "pretty_breaks"
#' @import dplyr tidyr ggplot2
EchogramCurtain <-
  function(the.dir,
           d.units,
           spgrp = c('X106.L0',
                     "X106.L100",
                     "X109.L0",
                     "X109.L90",
                     "X204.L0",
                     "X204.L120")) {
    the.dir <- choose.dir()
    flist <- list.files(the.dir, pattern = paste0("intlaymeans_",d.units), full.names = TRUE)

    dat <- read.csv(flist)

    # The remaining code between here and ggplot() fills cells where there is a missing density estimate because there
    # were either no targets or Sv was below threshold. These cases really ought to be filled with a zero.
    # What follows is my jankity attempt to do that.
    #
    # 1) create a data.frame() that mean bottom depth for each transect and interval
    bott.parms <- dat %>% group_by(Region_name, Interval) %>%
      summarise(bott = mean(depth.botmin))

    # 2) Create a data.frame that has all possible combinations of Interval-Layer-Layer_depth_min
    # This will be used as the "full" combination of cells given the intervals and bottom depths in each transect
    lay.parms.min <-
      expand.grid(
        Interval = unique(dat$Interval),
        Layer = unique(dat$Layer),
        Layer_depth_min = unique(dat$Layer_depth_min)
      )

    lay.parms.min$d <- (lay.parms.min$Layer * 10) - 10

    # 3) We don't want to plot (or create) data for cells that DON'T exist on a given transect. For example,
    # if Layer_depth_min does not exceed 90 meters for a transect-interval, we don't want to plot data
    # below that depth.
    # We create a subset of the possible cells if all depths were present on all transects (lay.parms.min)
    # that represents the combination of Interval-Layer actually present on the transects
    lay.parms.present <- subset(lay.parms.min, d == Layer_depth_min)

    set1 <-
      merge(bott.parms,
            lay.parms.present,
            by = c("Interval"),
            sort = TRUE)

    dat.fill <-
      merge(
        set1,
        dat,
        by = c("Region_name", "Interval", "Layer", "Layer_depth_min"),
        all.x = TRUE
      )

    dat.fill$depth.botmin.new <-
      ifelse(is.na(dat.fill$depth.botmin),
             dat.fill$bott,
             dat.fill$depth.botmin)

    dat.fill2 <- subset(dat.fill, Layer_depth_min < depth.botmin.new)

    #define cols we want to keep
    keep.cols <-c(
        "Region_name",
        "Interval",
        "Layer_depth_min",
        'fish_ha',
         spgrp)

    put.zero.cols <-
      (c('fish_ha', spgrp))

    dat.fill3 <- dat.fill2[c(keep.cols)]
    dat.fill3[, put.zero.cols][is.na(dat.fill3[, put.zero.cols])] <- 0
    dat.fill3$fish_ha[dat.fill3$fish_ha == Inf |
                        is.na(dat.fill3$fish_ha)] <- 0

    df <- dat.fill3

    df.long <-
      gather(df, spgrp, nph,-Region_name,-Layer_depth_min,-Interval)

    # Create the list of spgrp to loop through
    spgrp.list <- unique(df.long$spgrp)

    for (i in seq_along(spgrp.list)) {
      dat <- filter(df.long, spgrp == spgrp[i])
      Int <- as.factor(dat$Interval)
      Depth <- dat$Layer_depth_min
      fillvar <- dat$nph
      nam <- spgrp.list[i]
      p1 <-  ggplot() +
        geom_tile(
          data = filter(df.long, spgrp == spgrp.list[i]),
          aes(
            x = as.factor(Interval),
            y = -Depth,
            fill = nph
          ),
          stat = "identity"
        ) +
        scale_fill_viridis_c(
          paste0("Fish per hectare ", spgrp.list[i]),
          option = "plasma",
          breaks = pretty_breaks(n = 10)
        ) +
        scale_x_discrete("Interval", breaks = seq(min(dat$Interval), max(dat$Interval), 2)) +
        facet_wrap( ~ Region_name, scales = "free")
      ggsave(paste0(the.dir, "/", spgrp.list[i],"_", Sys.Date(), "_", d.units, "_echogram_curtain.png"), p1,
        dpi = 300,
        width = 12,
        height = 8)

    }
  }

#' Execute query of multiple Oracle trawl tables for use by EchoNet2Fish functions
#' @param year Numeric vector indicating the desired collection year(s).
#' @param lake Numeric vector indicating the desired collection lake(s).
#' @param lakec Character vector representing an abbreviation for the lake name.
#' This value is used to direct output files to the correct subfolder of the
#' folder in which the EchoNet2Fish reference file is located. For example, if
#' the path to this folder is C:/Documents/Acoustics/EchoNet2Fish and data are
#' from the year 2018 and lake with abbreviation (lakec) "MI", the output will
#' be written to the folder C:/Documents/Acoustics/EchoNet2Fish/MI2018.
#' @param target Numeric vector indicating the desired collection target(s).
#' @param rname Logical scalar indicating whether or not the user wishes to
#' rename certain fields to match requirements for the R package EchoNet2Fish
#' functions (see \code{\link{exploreACMT}} and \code{\link{estimateLake}}).
#' @param user Character vector providing the username used to connect to
#' the database.
#' @param password Character vector providing the password used to connect to
#' the database.
#' @param schma Character vector providing the schema used to connect to
#' the database. Default is "RVCAT".
#' @param outdir Character vector representing the parent directory in which the
#' output directory where data should be saved is located. The values for lakec and
#' year are pasted together with this directory name to provide the output location
#' for files generated by the function. This folder must exist already.
#' @param descr Character vector to include in the output file names to help identify
#' the data for later use. Default is "Acoustic".
#' @param typeset Numeric vector dictating which type of trawl data are needed.
#' Default value = 5 (Midwater).
#' @return
#'   Six different data frames are saved as objects in an Rdata file and are written to csv
#'   files in \code{outdir}:
#'   \itemize{
#'     \item \code{op} = Data from the RVCAT.OP table for the desired selection.
#'     \item \code{tr_op} = Data from the RVCAT.TR_OP table matching the operations
#'     in the op data.
#'     \item \code{tr_catch} = Data from the RVCAT.TR_CATCH table matching the
#'     operations in the op data
#'     \item \code{tr_lf} = Data from the RVCAT.TR_LF table matching the operations
#'     in the op data.
#'     \item \code{tr_l} = Data from the RVCAT.TR_L table matching the operations
#'     in the op data.
#'     \item \code{tr_fish} = Data from the RVCAT.TR_FISH table matching the operations
#'     in the op data.
#'     }
#' @import dplyr rtf graphics utils tidyr
#' @export

#' @details
#' This function queries the RVCAT database to obtain trawl data desired by the user.
#' It currently allows the user to determine if certain field names should be renamed
#' to match the requirements of Echonet2Fish functions.

trawl_query <- function(year = c(2019), lake = c(2,3),
                        lakec = c("MI", "HU"),
                        target = c(209, 210, 252),
                         rname = FALSE, user = username,
                        password = password, dbname = dbname, schma = "RVCAT",
                        descr = "LW acoustic survey", typeset = c(1, 2, 5), outdir = NULL) {

  drv <- dbDriver('Oracle')
  conn <- dbConnect(drv = drv,
    dbname = dbname,
    user = username,
    password = password
  )
  # Create local "information" about op table structure that can
  # be used in a query later
  #
  # Now op is a database object. The command above connects to the database
  # and downloads a bare minimum of information on fields, data types, etc.
  # enough to allow manipulation of the object without physical download
  # of the data
  # (https://towardsdatascience.com/how-to-write-tidy-sql-queries-in-r-d6d6b2a3e17)
  opdata <- dplyr::tbl(
    conn,
    dbplyr::in_schema("RVCAT", "OP")
  )

  # Create local "information" about op_target table structure that can
  # be used in a query later
  targetdata <- dplyr::tbl(
    conn,
    dbplyr::in_schema("RVCAT", "OP_TARGET")
  )

  # Create catch data object
  trcatchdata <- dplyr::tbl(
    conn,
    dbplyr::in_schema("RVCAT", "TR_CATCH")
  )

  # Create local "information" about tr_op table structure that can
  # be used in a query later
  tropdata <- dplyr::tbl(
    conn,
    dbplyr::in_schema("RVCAT", "TR_OP")
  )

  # Create tr_lf data object
  trlfdata <- dplyr::tbl(
    conn,
    dbplyr::in_schema("RVCAT", "TR_LF")
  )

  # Create tr_l data object
  trldata <- dplyr::tbl(
    conn,
    dbplyr::in_schema("RVCAT", "TR_L")
  )

  # Create tr_fish data object
  trfishdata <- dplyr::tbl(
    conn,
    dbplyr::in_schema("RVCAT", "TR_FISH")
  )

  # Filter op for correct year and lake, join with op_target, then filter
  # for the target(s) of interest
  if (rname == TRUE) {
    op <-
      filter(opdata, YEAR %in% year & LAKE %in% lake & SAMPLE_TYPE == 1) %>%
      left_join(targetdata, by = "OP_ID") %>% filter(TARGET %in% target)  %>%
      rename(
        "Op_Id" = "OP_ID",
        "Year" = "YEAR",
        "Vessel" = "VESSEL",
        "Beg_Depth" = "BEG_DEPTH",
        "End_Depth" = "END_DEPTH") %>%
      dplyr::collect()
  # Create list of OP_ID to use to subset the tr_op, tr_catch, and tr_lf
  opid <- op$Op_Id

  # Subset the tr_catch, tr_lf, tr_l, and tr_fish data to correspond to the desired OP_ID
  tr_op <- filter(tropdata, OP_ID %in% opid & typeset %in% typeset) %>%
    rename("Op_Id" = "OP_ID",   "Fishing_Depth" = "FISHING_DEPTH", "Fishing_temp" = "FISHING_TEMP",
           "Tow_Time" = "TOW_TIME") %>%
    dplyr::collect()

  tr_catch <- filter(trcatchdata, OP_ID %in% opid) %>%
    rename("Op_Id" = "OP_ID", "Species" = "SPECIES", "Weight" = "WEIGHT" ) %>%
    dplyr::collect()

  tr_lf <- filter(trlfdata, OP_ID %in% opid) %>%
    rename("Op_Id" = "OP_ID", "Species" = "SPECIES", "Length" = "LENGTH" ) %>%
    dplyr::collect()

  tr_l <- filter(trldata, OP_ID %in% opid) %>%
    rename("Op_Id" = "OP_ID", "Species" = "SPECIES", "Length" = "LENGTH" ) %>%
    dplyr::collect()

  tr_fish <- filter(trfishdata, OP_ID %in% opid) %>%
    rename("Op_Id" = "OP_ID", "Species" = "SPECIES", "Length" = "LENGTH",
           "Weight" ="WEIGHT", "AGE" = "AGE") %>%
    dplyr::collect()


  } else {
    op <-
      filter(opdata, YEAR %in% year & LAKE %in% lake & SAMPLE_TYPE == 1) %>%
      left_join(targetdata, by = "OP_ID") %>% filter(TARGET %in% target)  %>%
      dplyr::collect()

    # Create list of OP_ID to use to subset the tr_op, tr_catch, and tr_lf
    opid <- op$OP_ID

    # Subset the tr_catch, tr_lf, tr_l, and tr_fish data to correspond to the desired OP_ID
    tr_op <- filter(tropdata, OP_ID %in% opid & typeset %in% typeset) %>%
      dplyr::collect()

    tr_catch <- filter(trcatchdata, OP_ID %in% opid) %>%
      dplyr::collect()

    tr_lf <- filter(trlfdata, OP_ID %in% opid) %>%
      dplyr::collect()

    tr_l <- filter(trldata, OP_ID %in% opid) %>%
      dplyr::collect()

    tr_fish <- filter(trfishdata, OP_ID %in% opid) %>%
      dplyr::collect()
  }

  save2csv <-
    c(
      "op",
      "tr_op",
      "tr_catch",
      "tr_lf",
      "tr_l",
      "tr_fish"
    )

  newrdat <- paste0("L", lake, " Y", year, " ", descr)
  lakeyr <- ifelse(lake == 2, paste0("MI", year), paste0("HU", year))
  #save(list = save2csv,
  #     file = paste0(outdir, "/", lakeyr, "/", newrdat, ".RData"))
  outfiles <- paste0(outdir, "/", lakeyr, "/",
                     "L_",
                     lake,
                     "_Y_",
                     year,
                     "_",
                     descr,
                     "_",
                     save2csv,
                     ".csv")
  invisible(lapply(seq(save2csv), function(i)
    write.csv(eval(
      parse(text = save2csv[i]),
    ),
    outfiles[i], row.names = F)))

}

